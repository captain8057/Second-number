// num2.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

// prime numbers.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#define N 100

int rank, size;
double start_time;
double end_time;

int y, x, i, port1, port2, port3;
int check = 0;         // prime number checker, if a number is prime it always remains 0      through out calculation. for a number which is not prime it is turns to value 1 at some    point
int signal = 0;       // has no important use. just to check if slave process work is done.

MPI_Status status;
MPI_Request request;

int main(int argc, char *argv[]) {
	MPI_Init(&argc, &argv); //initialize MPI operations
	MPI_Comm_rank(MPI_COMM_WORLD, &rank); //get the rank
	MPI_Comm_size(MPI_COMM_WORLD, &size); //get number of processes

	if (rank == 0) {                  // master process divides work and also does initial  work itself
		start_time = MPI_Wtime();
		printf("2\n");                  //print prime number 2 first  because the algorithm for finding the prime number in this program is just for odd number
		port1 = (N / (size - 1));           // calculating the suitable amount of work per process

		for (i = 1;i<size - 1;i++) {            // master sending the portion of work to each   slave
			port2 = port1 * i;              // lower bound of work for i th  process 
			port3 = ((i + 1)*port1) - 1;        // upper bound of work for i th process
			MPI_Isend(&port2, 1, MPI_INT, i, 100, MPI_COMM_WORLD, &request);
			MPI_Isend(&port3, 1, MPI_INT, i, 101, MPI_COMM_WORLD, &request);
		}

		port2 = (size - 1)*port1; port3 = N;     // the last process takes the remaining work
		MPI_Isend(&port2, 1, MPI_INT, (size - 1), 100, MPI_COMM_WORLD, &request);
		MPI_Isend(&port3, 1, MPI_INT, (size - 1), 101, MPI_COMM_WORLD, &request);

		for (x = 3; x < port1; x = x + 2) {    // master doing initial work by itself
			check = 0;
			for (y = 3; y <= x / 2; y = y + 2) {
				if (x%y == 0) { check = 1; break; }
			}
			if (check == 0)  printf(" I am runk is %d : %d\n", rank, x);
		}
	}

	if (rank > 0) {                    // slave working part

		MPI_Recv(&port2, 1, MPI_INT, 0, 100, MPI_COMM_WORLD, &status);
		MPI_Recv(&port3, 1, MPI_INT, 0, 101, MPI_COMM_WORLD, &status);
		if (port2 % 2 == 0) port2++;                                        // changing the even  argument to odd to make the calculation fast because even number is never a prime except 2.
		for (x = port2; x <= port3; x = x + 2) {
			check = 0;
			for (y = 3; y <= x / 2; y = y + 2) {
				if (x%y == 0) { check = 1; break; }
			}
			if (check == 0) printf(" I am runk is %d : %d\n", rank, x);
		}
		signal = rank;
		MPI_Isend(&signal, 1, MPI_INT, 0, 103, MPI_COMM_WORLD, &request);  // just informing  master that the work is finished

	}

	if (rank == 0) {                                                    // master concluding the work and printing the time taken to do the work
		for (i == 1; i < size; i++) {
			MPI_Recv(&signal, 1, MPI_INT, i, 103, MPI_COMM_WORLD, &status);  // master confirming that all slaves finished their work
		}
		end_time = MPI_Wtime();
		//printf("\nRunning Time = %f \n\n", end_time - start_time);
	}
	MPI_Finalize();
	return 0;
}

